-- Add Spotify-backed songs + per-video tracklists

create table if not exists public.songs (
    id bigint generated by default as identity primary key,
    spotify_track_id text not null unique,
    spotify_url text not null,
    title text not null,
    artist text not null,
    duration_ms integer,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists public.video_songs (
    id bigint generated by default as identity primary key,
    video_id bigint not null references public.media_items(id) on delete cascade,
    song_id bigint not null references public.songs(id) on delete cascade,
    start_offset_seconds integer not null check (start_offset_seconds >= 0),
    start_timecode text,
    position integer not null check (position >= 1),
    source text not null default 'manual' check (source in ('automation', 'manual')),
    import_source text check (import_source in ('youtube_chapters', 'youtube_music', 'mixed')),
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    unique(video_id, song_id)
);

create index if not exists songs_spotify_track_id_idx on public.songs (spotify_track_id);
create index if not exists video_songs_video_id_position_idx on public.video_songs (video_id, position);
create index if not exists video_songs_video_id_idx on public.video_songs (video_id);
create index if not exists video_songs_song_id_idx on public.video_songs (song_id);

alter table public.songs enable row level security;
alter table public.video_songs enable row level security;

drop policy if exists "Songs are readable" on public.songs;
create policy "Songs are readable" on public.songs for select using (true);

drop policy if exists "Video songs are readable" on public.video_songs;
create policy "Video songs are readable" on public.video_songs for select using (true);

-- Keep updated_at fresh (re-using helper from watch_history migration)
drop trigger if exists set_songs_updated_at on public.songs;
create trigger set_songs_updated_at before update on public.songs
    for each row
    execute function public.set_current_timestamp_updated_at();

drop trigger if exists set_video_songs_updated_at on public.video_songs;
create trigger set_video_songs_updated_at before update on public.video_songs
    for each row
    execute function public.set_current_timestamp_updated_at();

comment on table public.songs is 'Spotify track metadata (used for per-video tracklists).';
comment on table public.video_songs is 'Join table linking a movie (media_items) to songs with timestamps and ordering.';
comment on column public.video_songs.start_timecode is 'Optional preserved formatting (mm:ss or hh:mm:ss) for display.';
comment on column public.video_songs.source is 'How the track was attached: automation or manual.';
comment on column public.video_songs.import_source is 'If source=automation, where it came from (YouTube chapters, YouTube music, mixed).';
