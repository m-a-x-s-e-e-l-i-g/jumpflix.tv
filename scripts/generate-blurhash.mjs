#!/usr/bin/env node
// Generate BlurHash strings for all poster images and write a TS mapping.
// Reads from static/images/posters and writes to src/lib/assets/blurhash.ts

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import sharp from 'sharp';
import { encode } from 'blurhash';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, '..');
const POSTERS_DIR = path.join(ROOT, 'static', 'images', 'posters');
const OUT_FILE = path.join(ROOT, 'src', 'lib', 'assets', 'blurhash.ts');

const exts = new Set(['.webp', '.jpg', '.jpeg', '.png']);

async function listFilesRecursive(dir) {
	const entries = await fs.readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const full = path.join(dir, entry.name);
			if (entry.isDirectory()) return listFilesRecursive(full);
			if (exts.has(path.extname(entry.name).toLowerCase())) return [full];
			return [];
		})
	);
	return files.flat();
}

async function fileToBlurhash(file) {
	// Load and convert to raw RGBA pixels
	const { data, info } = await sharp(file)
		.ensureAlpha()
		.raw()
		.toBuffer({ resolveWithObject: true });
	const pixels = new Uint8ClampedArray(data);
	// 4x4 components is a good balance of size/quality
	const blurhash = encode(pixels, info.width, info.height, 4, 4);
	return blurhash;
}

function toPublicPath(absPath) {
	// Convert absolute path like .../static/images/posters/foo.webp to
	// the public URL used in code: /images/posters/foo.webp
	const idx = absPath.replace(/\\/g, '/').lastIndexOf('/static/');
	if (idx === -1) throw new Error(`Unexpected path (no /static/): ${absPath}`);
	const relFromStatic = absPath.replace(/\\/g, '/').slice(idx + '/static'.length);
	return relFromStatic;
}

async function main() {
	const argv = new Set(process.argv.slice(2));
	const force = argv.has('--force') || argv.has('-f');

	// Load existing mapping so we can skip recomputation
	let existing = {};
	try {
		const existingContent = await fs.readFile(OUT_FILE, 'utf-8');
		const re = /"([^\"]+)":\s*"([^\"]+)"/g;
		for (const m of existingContent.matchAll(re)) {
			existing[m[1]] = m[2];
		}
	} catch {}

	let outMtimeMs = 0;
	try {
		const stat = await fs.stat(OUT_FILE);
		outMtimeMs = stat.mtimeMs;
	} catch {}

	console.log(`Scanning for poster images in: ${POSTERS_DIR}`);
	const files = await listFilesRecursive(POSTERS_DIR);
	console.log(`Found ${files.length} candidate files`);
	if (!files.length) {
		console.error(`No poster files found in ${POSTERS_DIR}`);
		process.exit(1);
	}

	const map = { ...existing };
	let processed = 0;
	let updated = 0;
	let skipped = 0;
	const presentKeys = new Set();
	for (const file of files) {
		try {
			const key = toPublicPath(file);
			presentKeys.add(key);
			// If we already have this key and not forcing, skip unless source is newer than output
			if (!force && existing[key]) {
				const stat = await fs.stat(file);
				if (stat.mtimeMs <= outMtimeMs) {
					skipped += 1;
					continue;
				}
			}
			console.log(`Encoding: ${file}`);
			const hash = await fileToBlurhash(file);
			if (existing[key] && existing[key] !== hash) updated += 1;
			else processed += 1;
			map[key] = hash;
		} catch (e) {
			console.warn(`Failed to process ${file}:`, e?.message || e);
		}
	}

	// Optionally prune entries that no longer exist on disk
	if (argv.has('--prune')) {
		for (const key of Object.keys(map)) {
			if (!presentKeys.has(key)) delete map[key];
		}
	}

	const sortedKeys = Object.keys(map).sort((a, b) => a.localeCompare(b));
	const entries = sortedKeys
		.map((k) => `  ${JSON.stringify(k)}: ${JSON.stringify(map[k])},`)
		.join('\n');
	const content =
		`// AUTO-GENERATED by scripts/generate-blurhash.mjs. Do not edit by hand.\n` +
		`// Maps public poster paths to their BlurHash strings.\n` +
		`export const posterBlurhash: Record<string, string> = {\n${entries}\n} as const;\n`;

	await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
	await fs.writeFile(OUT_FILE, content);
	console.log(`BlurHash generation complete.`);
	console.log(`  New: ${processed}`);
	console.log(`  Updated: ${updated}`);
	console.log(`  Skipped (up-to-date): ${skipped}`);
	console.log(`  Total entries: ${sortedKeys.length}`);
	console.log(`Wrote mapping to ${path.relative(ROOT, OUT_FILE)}`);
}

main().catch((err) => {
	console.error(err);
	process.exit(1);
});
