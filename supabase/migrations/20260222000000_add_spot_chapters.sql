-- Approved spot chapters (persisted, separate from content_suggestions audit log)

create table if not exists public.spot_chapters (
    id bigint generated by default as identity primary key,
    media_id bigint not null references public.media_items(id) on delete cascade,
    media_type text not null check (media_type in ('movie', 'series')),
    -- For movies this stays empty; for series it identifies the episode playback key.
    playback_key text not null default '',
    spot_id text not null,
    start_seconds integer not null,
    end_seconds integer not null,
    created_from_suggestion_id bigint references public.content_suggestions(id) on delete set null,
    approved_by uuid references auth.users(id) on delete set null,
    approved_at timestamptz not null default timezone('utc', now()),
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    constraint spot_chapters_non_empty_spot_id check (length(trim(spot_id)) > 0),
    constraint spot_chapters_start_non_negative check (start_seconds >= 0),
    constraint spot_chapters_end_after_start check (end_seconds > start_seconds),
    constraint spot_chapters_series_requires_playback_key check (
        media_type <> 'series' or length(trim(playback_key)) > 0
    )
);

create index if not exists spot_chapters_media_id_idx on public.spot_chapters (media_id);
create index if not exists spot_chapters_lookup_idx on public.spot_chapters (media_id, media_type, playback_key, start_seconds);

-- Avoid approving the exact same spot range more than once.
create unique index if not exists spot_chapters_unique_idx
    on public.spot_chapters (media_id, media_type, playback_key, start_seconds, end_seconds, spot_id);

alter table public.spot_chapters enable row level security;

-- Spot chapters contain no personal data; allow public reads.
drop policy if exists "Spot chapters are readable" on public.spot_chapters;
create policy "Spot chapters are readable" on public.spot_chapters
  for select
  using (true);

-- Keep updated_at fresh
-- Re-use helper: public.set_current_timestamp_updated_at()
drop trigger if exists set_spot_chapters_updated_at on public.spot_chapters;
create trigger set_spot_chapters_updated_at before update on public.spot_chapters
    for each row
    execute function public.set_current_timestamp_updated_at();

comment on table public.spot_chapters is 'Approved parkour spot chapters for media items. Written by admins via moderation; publicly readable.';
comment on column public.spot_chapters.playback_key is 'Episode playback key for series chapters; empty for movies.';
comment on column public.spot_chapters.created_from_suggestion_id is 'Back-reference to the original content_suggestions row (audit trail).';
